::GeneralFunctions [script] <200,50>
Config.saves.isAllowed = function (saveType) {
    if (saveType === Save.Type.Auto) {
        if (settings.autosave && !tags().includes('noreturn')){
            return true;
        }
        return false;
    }
    else {
        if (tags().includes('noreturn')) {
            return false;
        }
        return true;
    }
};
Config.saves.maxAutoSaves = 1;
Setting.addToggle("autosave", {
    label       : "Autosaves",
    default     : true,
});
Setting.addToggle("autoname", {
    label       : "Autoname Saves",
    default     : true,
});
Setting.addToggle("abortionAllowed", {
    label       : "Abortion Allowed",
    default     : true,
    desc        : "Turning off removes the option for an abortion in most cases"
});
Setting.addToggle("randomSelect", {
    label       : "Random override",
    default     : true,
    desc        : "Can the player choose some options that would otherwise be randomly assigned"
});


Config.saves.descriptions = function (saveType) {
    switch (saveType) {
        case Save.Type.Auto: {
            return "Autosave: " + (State.getVar("$playerName") || "New Player") + " - " + setup.getCurrentPassageSummary();
            break;
        }
        default: {
            if (settings.autoname) {
                return (State.getVar("$playerName") || "New Player") + " - " + setup.getCurrentPassageSummary();
            }
            else {
                return prompt("Enter Save Name:", State.getVar("$playerName") + " - " + setup.getCurrentPassageSummary());
            }
        }
    }
};

setup.getCurrentPassageSummary = function() {
  const text = $("#passages div")[0].outerHTML;
  const h1Match = text.match(/<h1>(.*)<\/h1>/)
  return (h1Match ? h1Match[1] : text).replace(/<\/[^>]+(>|$)/g, "").slice(0, 30)
}

setup.getPopularNames = function () {
  return ["Abigail","Taylor","Alyssa","Lauren","Brianna","Anna","Destiny","Jasmine","Jennifer","Julia","Isabella","Morgan"]
}

setup.pickRandomName = function (names) {
	var randomIndex = Math.floor(Math.random() * names.length)
	return names[randomIndex]
}

setup.getDefaultName = function () {
  return setup.pickRandomName(setup.getPopularNames());
}

setup.removeItem = function (arr, item) {
	var index = arr.indexOf(item)
	if (index < 0) {
		return arr
	} else {
  	return arr.slice(0,index).concat(arr.slice(index+1))
	}
}

setup.addIfNeeded = function (arr, item) {
	var index = arr.indexOf(item)
	if (index < 0) {
		return arr.concat([item])
	} else {
		return arr
	}
}

setup.kidNameList = function () {
  var kids = variables().children.map((child) => {return child.name});
  if (kids.length == 0) {
    return "";
  } else if (kids.length == 1) {
    return kids[0];
  } else {
    return kids.slice(0, kids.length - 1).join(", ") + " and " + kids[kids.length - 1];
  }
}

::AutoNav [script] <250,50>
var IntervalID = setInterval(UpdateLinks, 300);

$(document).on(':passageend', function (ev) {
	clearInterval(IntervalID);
	IntervalID = setInterval(UpdateLinks, 300);  // Triggers UpdateLinks() 300ms after the passage is rendered.
});

function UpdateStoryLinks() {
  if ($("#StoryKeyFlag").html()) {
    $("#StoryKeyFlag").html("")
    var storyLinkId = variables().StoryKeys[0] - 1;
    variables().StoryKeys = variables().StoryKeys.slice(1);

    var Links = $("#passages a");
    if (Links.length === 1) {
      //only one link anyway
      Links[0].id = "NextLink";
      return;
    }

    if (storyLinkId >= Links.length) {
      console.warn("storyLinkId: " + storyLinkId + ", Links.length: " + Links.length + " : Exiting story mode");
      variables().StoryKeys = "";
      return;
    }

    let i = 0
    Links.each(function()
    {
      if (i == storyLinkId) {
        this.id = "NextLink";
      } else {
        this.outerHTML = this.innerHTML;
      }
      i++;
    });
  }
}

// Search passages for links every 300ms and marks them for key clicks
function UpdateLinks() {
	if (Engine.isIdle()) {
    var NoKeyLinks = $(".NoKeyLinks");
    if (variables().StoryKeys) {
      UpdateStoryLinks()
    } else if (NoKeyLinks.length > 0 ) {
      // to nothing
    } else {
      var Links = $("#passages a.link-internal");
      // console.log(JSON.stringify(Links));
      if (Links.length === 1) {
        Links[0].id = "NextLink";
      } else if (Links.length >= 1 && Links.length <= 10) {
        var n = 1;
        for (var i = 0; i < Links.length; i++) {
          if (!Links[i].id.includes("Link")) {
            while ($('#Link' + n).length) {
              ++n;
              if (n > 10) {
                break;
              }
            }

            if (n < 10) {
              $("<sup>[" + n + "]</sup>").appendTo(Links[i]);
              Links[i].id = "Link" + n;
            } else if (n === 10) {
              $("<sup>[0]</sup>").appendTo(Links[i]);
              Links[i].id = "Link0";
            }
            if (n >= 10) {
              break;
            }
          }
        }
      }
    }
	}
};

$(document).on("keyup", function (e) {
	// Trigger next link click on right arrow key
	if (((e.key == "ArrowRight") || (e.keyCode == 49) || (e.keyCode == 97)) && $("#NextLink").length && (!tags().includes("DisableClick"))) {
		e.preventDefault();
    variables().StoryKeysLearn += "1"
		$("#NextLink").trigger("click");
		return false;
	}

	// Trigger link click on keys "0" through "9"
	if ((e.keyCode > 47) && (e.keyCode < 58) && (!tags().includes("DisableClick"))) {
		if ($("#Link" + (e.keyCode - 48)).length) {
			e.preventDefault();
      variables().StoryKeysLearn += (e.keyCode - 48)
			$("#Link" + (e.keyCode - 48)).trigger("click");
			return false;
		}
	}
	if ((e.keyCode > 95) && (e.keyCode < 106) && (!tags().includes("DisableClick"))) {
		if ($("#Link" + (e.keyCode - 96)).length) {
			e.preventDefault();
      variables().StoryKeysLearn += (e.keyCode - 96)
			$("#Link" + (e.keyCode - 96)).trigger("click");
			return false;
		}
	}

	// Trigger random click on ".", "`", and "r" keys
	if (([".", "`", "r"].includes(e.key)) && (!tags().includes("DisableClick")) && (!tags().includes("DisableRandom"))) {
		e.preventDefault();
		var Links = $("#passages a");
		if (Links.length > 0) {
      variables().StoryKeysLearn += ":RANDOM:"
			Links[Math.floor(Math.random() * Links.length)].click();
			return false;
		}
	}

	// Trigger back click on left arrow key
	if ((e.key == "ArrowLeft") && (!tags().includes("DisableClick"))) {
		e.preventDefault();
		Engine.backward();
		return false;
	}

	if ((["x"].includes(e.key)) && (!tags().includes("DisableClick"))) {
		e.preventDefault();
    variables().StoryKeys = "";
    if ($("#StoryModeMessage").html()) {
      $("#StoryModeMessage").html("<i>Story Mode Exited - Normal navigation resumes on next page</i>");
    }
    return false;
  }
});

::InventoryFunctions [script] <275,50>
setup.addInventory = function (itemClass, itemName) {
  if (!variables().inventory[itemClass]) {
    variables().inventory[itemClass] = []
  }
  variables().inventory[itemClass] = setup.addIfNeeded(variables().inventory[itemClass], itemName)
}

setup.haveInventory = function (itemClass, itemName) {
  if (!variables().inventory[itemClass]) {
    return false
  } else if (itemName === '*') {
    return true
  } else {
    return variables().inventory[itemClass].indexOf(itemName) >= 0
  }
}

setup.removeInventory = function(itemClass, itemName) {
  if (setup.haveInventory(itemClass, itemName)) {
    variables().inventory[itemClass] = setup.removeItem(variables().inventory[itemClass], itemName)
    return true;
  } else {
    return false;
  }
}

setup.listInventory = function(itemClass) {
  if (!variables().inventory[itemClass]) {
    return "none"
  } else {
    return variables().inventory[itemClass].join(", ")
  }
  
}

::WeekFunctions [script] <295,50>>
setup.advanceWeek = function() {
  setup.addMinimumBJs()
  setup.addTutorSex()
  setup.nextCycleWeek()
  if (variables().SchoolWeek) {
    variables().SchoolWeek += 1
  }
}

setup.startCycle = function (startWeekIsRandom, forgetPill) {
  let startWeek = startWeekIsRandom ? Math.floor(Math.random() * 4) : 0
  variables().MenstrualWeek = startWeek + 1
}

setup.nextCycleWeek = function (forgetPill) {
  setup.checkForNewPregnancyHidden()
  if (variables().PregnancyWeek == -1) {
    variables().PregnancyWeek = 1; //if getting pregnant right after their period
  } else if (variables().PregnancyWeek) {
    variables().PregnancyWeek += 1;
  } else if (variables().MenstrualWeek) {
    variables().MenstrualWeek += 1;
    if (variables().MenstrualWeek == 5) {
      variables().MenstrualWeek = 1;
    }
  } else {
    setup.startCycle(false, forgetPill)
  }

  if (variables().MenstrualWeek == 4) {
    setup.checkForNewPregnancy("period")
  }
}

::SexFunctions [script] <300,50>
setup.addSex =  function (fuck) {
  if (fuck.analAccident) {
    fuck.noCondom = true;
    fuck.noPullout = true;
  }
  if (!fuck.count) {
    fuck.count = 1;
  }
  variables().sex.push(fuck)
  if (fuck.vaginal && variables().LoopholeVirgin) {
    variables().LoopholeVirgin = undefined;
  }
}

setup.addSexRepeat = function (repeatCount, fuck) {
  if (fuck.vaginal || fuck.anal) {
    // could result in pregnancy, so process individually
    for (let i = 0; i < repeatCount; i++) {
      setup.addSex({...fuck});
    }
  } else {
    setup.addSex({...fuck, count: repeatCount});
  }
}

setup.checkForBuddyPregnancy = function (repeatCount, guys) {
  if (!guys) {guys=[]};

  var chanceEachTime = variables().BuddyCondoms ? 0.02 : 0.1;

  for (var i = 0; i < repeatCount; i++) {
    var currGuy = (guys.length > i) ? guys[i] : "Unknown";

    if (Math.random() < chanceEachTime) {
      return currGuy;
    }
  }

  return undefined;
}



setup.addTutorSex = function() {
  if (variables().AcademicProbationTutorSex && variables().AcademicProbation) {
    variables().AcademicProbationTutorSex.forEach(setup.addSex)
  }
}

setup.addMinimumBJs = function() {
  var fuck
  if (setup.haveGirlfriend()) {
    fuck = {sex: 'female', name: variables().dating[0]};
  } else if (variables().dating.length) {
    fuck = {sex: 'male', name: variables().dating[0]};
  } else {
    fuck = {sex: 'male'};
  }

  if (variables().DailyBJMinimum) {
    setup.addSexRepeat(variables().DailyBJMinimum * 7, fuck);
  }
}

setup.sumSexCount = function(fucks) {
  if (fucks.length == 0) return 0;
  return fucks.map(fuck => fuck.count || 1).reduce((prev, next) => prev + next);
}

setup.sexCount = function () {
  if (!variables().sex) return 0;
	return setup.sumSexCount(variables().sex)
}

setup.sexMaleCount = function () {
  if (!variables().sex) return 0;
	return setup.sumSexCount(variables().sex.filter(function(fuck) {return fuck.sex == 'male'}))
}

setup.sexFemaleCount = function () {
  if (!variables().sex) return 0;
	return setup.sumSexCount(variables().sex.filter(function(fuck) {return fuck.sex == 'female'}))
}

setup.sexVaginalCount = function () {
  if (!variables().sex) return 0;
	return setup.sumSexCount(variables().sex.filter(function(fuck) {return fuck.sex == 'male' && fuck.vaginal}))
}

setup.sexUniquePartners = function (fucks) {
  if (!fucks || fucks.length == 0) return []
	var named = fucks.filter(function(fuck) {return fuck.name})
	var names = named.map(function(namedFuck) {return namedFuck.name})
	return Array.from(new Set(names))
}

setup.sexAllUniquePartners = function () {
	return setup.sexUniquePartners(variables().sex)
}

setup.sexUniqueCount = function (fucks) {
	var unnamed = fucks.filter(function(fuck) {return !fuck.name && !fuck.repeat})
	return setup.sumSexCount(unnamed) + setup.sexUniquePartners(fucks).length
}

setup.sexUniqueMaleCount = function () {
  if (!variables().sex) return 0;
	return setup.sexUniqueCount(variables().sex.filter(function(fuck) {return fuck.sex == 'male' && !fuck.repeat}))
}

setup.sexUniqueFemaleCount = function () {
  if (!variables().sex) return 0;
	return setup.sexUniqueCount(variables().sex.filter(function(fuck) {return fuck.sex == 'female' && !fuck.repeat}))
}

setup.sexUniqueVaginalCount = function () {
  if (!variables().sex) return 0;
	return setup.sexUniqueCount(variables().sex.filter(function(fuck) {return fuck.sex == 'male' && fuck.vaginal && !fuck.repeat}))
}

setup.isGoldStarLesbian = function () {
	return setup.sexVaginalCount() == 0 && setup.sexFemaleCount() > 0
}

setup.getPartnerName = function(fuck) {
  if (fuck.name) {
    var kidnapperNote = (variables().KidnapEscape && fuck.name.indexOf("Kidnapper") >= 0) ? " (no memory)" : ""
    return fuck.name + kidnapperNote
  } else if (fuck.anon) {
    return "Some " + fuck.anon
  } else if (fuck.sex == 'male') {
    return "Some Guy"
  } else if (fuck.sex == 'purple') {
    return "Someone"
  } else {
    return "Some Girl"
  }
}

setup.sexualHistoryTable = function () {
	if (!variables().sex || variables().sex.length == 0) {
		return "You are still a virgin.  You must be new here."
	}

	var st = "<table>\n<tr><th>Name / Description</th><th>M/F</th><th>Vaginal?</th><th>Birth Control</th><th>Pregnancy</th></tr>\n"
	variables().sex.forEach(function (fuck) {
		st += "<tr><td>"
    var partnerName = setup.getPartnerName(fuck)
    if (partnerName.indexOf("Some") >= 0) {
      st += "<i>(" + partnerName + ")</i>"
    } else {
      st += partnerName
    }
    if (fuck.count > 1) {
      st += ` x${fuck.count}`;
    }
		st += "</td><td>" + fuck.sex + "</td><td>" + (fuck.vaginal ? "Y" : "") + "</td><td>"
			 + (fuck.vaginal ? fuck.birthControl : "")
			 + (fuck.ovulating ? " (ovulating) " : "")
       + (fuck.analAccident ? " (anal accident) " : "")
			 + "</td><td>"
    if (fuck.conception) {
      if (fuck.aborted) {
        st += "(Aborted)"
      } else if (fuck.miscarriage) {
        st += "(Miscarriage)"
      } else {
        st += "CONCEPTION"
      }
    } else if (fuck.checkedForPregnancy) {
      st += "no: " + fuck.checkedForPregnancy
    } else if (fuck.vaginal || fuck.analAccident) {
      st += "?"
    }
    st += "</td></tr>\n"
	})
  return st + "</table>\n"
}

setup.haveFucked = function (name) {
	return variables().sex.filter(function(fuck) {return fuck.name == name || fuck.anon == name}).length > 0
} 

setup.haveFuckedMale = function (name) {
	return variables().sex.filter(function(fuck) {return fuck.sex == 'male' && (fuck.name == name || fuck.anon == name)}).length > 0
}

setup.haveFuckedVaginal = function (name) {
	// different than daddyCheck, since doesn't care about birth control
	return variables().sex.filter(function(fuck) {return fuck.vaginal && (fuck.name == name || fuck.anon == name)}).length > 0
}

setup.hadAnalAccident = function (name) {
	return variables().sex.filter(function(fuck) {return fuck.analAccident && (fuck.name == name || fuck.anon == name)}).length > 0
}

setup.haveConceivedWith = function (name) {
  return variables().sex.filter(function(fuck) {return fuck.conception && (fuck.name == name || fuck.anon == name)}).length > 0
}

setup.addDetailsToRecentSex = function() {
	if (!variables().sex) return;

	variables().sex.forEach(function(fuck) {
		if((fuck.vaginal || fuck.analAccident) && !fuck.checkedForPregnancy) {
      if (!fuck.birthControl) {
        if (variables().PlayerPregnant) {
          fuck.birthControl = 'pregnant'
        } else if (variables().PlayerProtectionPerfect) {
          fuck.birthControl = 'implant-perfect'
				} else if (variables().PlayerProtectionPrince) {
					fuck.birthControl = 'injection'
        } else if (fuck.birthControlOverride) {
          fuck.birthControl = fuck.birthControlOverride
        } else if (variables().HalloweenCondoms && !fuck.noCondom) {
          fuck.birthControl = 'condom'
        } else if (variables().PlayerProtectionPermanent) {
          fuck.birthControl = 'implant-pill'
        } else if (variables().PlayerProtectionPill && !fuck.noPill) {
          fuck.birthControl = 'pill'
        } else if ((variables().PlayerProtectionCondoms && !fuck.noCondom) || fuck.condom) {
          fuck.birthControl = 'condom'
        } else if ((variables().PlayerProtectionWithdraw && !fuck.noPullout)  || fuck.pullout) {
          fuck.birthControl = 'pullout'
        } else {
          fuck.birthControl = 'none'
        }
      }

      if (variables().PlayerProtectionTry) {
        fuck.trying = true
      }

      if (fuck.birthControl == 'pregnant') {
        fuck.checkedForPregnancy = 'already pregnant'
      } else if (fuck.birthControl == 'implant-perfect') {
        fuck.checkedForPregnancy = 'perfect implant'
      } else if (fuck.birthControl == 'injection') {
        fuck.checkedForPregnancy = 'injection'
      } else if (fuck.birthControl == 'cycle') {
        fuck.checkedForPregnancy = 'wrong time of month'
      } else if (fuck.birthControl == 'vasectomy') {
        fuck.checkedForPregnancy = 'partner had vasectomy'
      } else if (fuck.birthControl == 'pullout-perfect') {
        fuck.checkedForPregnancy = 'early pullout'
      } else if (fuck.birthControl == 'goo') {
        fuck.checkedForPregnancy = 'sample did not contain sperm'
      } else if (fuck.birthControl == 'careful condom') {
        fuck.checkedForPregnancy = 'condom (careful)'
      }
		}
	})
}

setup.getPossibleConceptions = function(hideHiddenChecked) {
  setup.addDetailsToRecentSex()
  return variables().sex.filter(function(fuck) {
    var shouldHide = fuck.checkedForPregnancy && (fuck.checkedForPregnancy != "hidden" || hideHiddenChecked)

    return (fuck.vaginal || fuck.analAccident) &&
      !shouldHide &&
      fuck.birthControl != 'pregnant' &&
      fuck.birthControl != 'implant-perfect' &&
      fuck.birthControl != 'injection' &&
      fuck.birthControl != 'cycle' &&
      fuck.birthControl != 'vasectomy' &&
      fuck.birthControl != 'pullout-perfect' &&
			fuck.birthControl != 'goo'
  })
}

setup.firstTimeWith = function() {
  var intercourse = variables().sex.filter(function(fuck) {return fuck.vaginal})
  if (intercourse.length) {
    return intercourse[0].name || ("Some " + intercourse[0].anon);
  } else {
    return "no one"
  }
}

setup.isFirstVaginal = function(targetFuck) {
  var intercourse = variables().sex.filter(function(fuck) {return fuck.vaginal})
  return intercourse.length && intercourse[0] == targetFuck
}

setup.pregnantFirstTime = function() {
  var intercourse = variables().sex.filter(function(fuck) {return fuck.vaginal})
  return intercourse.length && intercourse[0].conception && !intercourse[0].trying
}

setup.pregnantFromLoophole = function() {
  var analAccidentConception = variables().sex.filter(function(fuck) {return fuck.analAccident && fuck.conception})
  return analAccidentConception && (setup.sexVaginalCount() == 0)
}

setup.notPregnant = function(reason) {
  setup.getPossibleConceptions().forEach(function(fuck) {
    fuck.checkedForPregnancy = reason
  })
}

setup.checkForPregnancy = function (fuck, oddsBoost, ovulationOverride) {
  var ovulationTableNormal = [
    0.05, 0.01, 0, 0, 0, 0.01, 0.05,
    0.1, 0.1, 0.2, 0.5, 0.5, 0.5, 0.5,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    0.5, 0.5, 0.5, 0.5, 0.2, 0.1, 0.1
  ]
  var ovulationTableExtraFertile = [
    0, 0, 0, 0.1, 0.1, 0.2, 0.2, 0.5,
    0.5, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0,
    1.0, 1.0, 0.5, 0.2, 0.2, 0.1, 0.1
  ]
  
  var ovulationRoll
  if (variables().MenstrualWeek) {
    ovulationRoll = Math.floor(Math.random() * 7) + (variables().MenstrualWeek % 4) * 7
  } else {
    ovulationRoll = Math.floor(Math.random() * 28)
  }
  var baseProbability
  if (ovulationOverride) {
    baseProbability = variables().PlayerProtectionFertile ? 1.0 : 0.6
  } else if (variables().PlayerProtectionFertile) {
    baseProbability = ovulationTableExtraFertile[ovulationRoll]
  } else {
    baseProbability = ovulationTableNormal[ovulationRoll]
  }

  var protectionFactor = 1.0
  if ((fuck.birthControl == 'implant-pill' || fuck.birthControl == 'pill') && !fuck.ovulating) {
    protectionFactor = 0.01
  } else if (fuck.birthControl == 'condom') {
    protectionFactor = 0.05
  } else if (fuck.birthControl == 'pullout') {
    protectionFactor = 0.1
  }

  var orgasmFactor = (variables().PlayerEasytoOrgasm ? 1.25 : 1.0) * (variables().PlayerPowerfulOrgasms ? 1.25 : 1.0)  * (variables().PlayerSuperOrgasms ? 1.25 : 1.0);
  var conceptionChance = baseProbability * protectionFactor * orgasmFactor;
  var conceptionRoll = Math.random()
  return conceptionRoll < conceptionChance;
}

setup.getUnrevealedPregnancy = function(pregnancyTestType) {
  var recentVaginal = setup.getPossibleConceptions()
  const actualEvent = recentVaginal.find(function(fuck) {
    return fuck.conception
  });

  let reason = pregnancyTestType || "pregnancy test";
  recentVaginal.forEach(function(fuck) {
    if (fuck.conception) {
      reason = "already pregnant"
    } else {
      fuck.checkedForPregnancy = reason
    }
  });

  return actualEvent;
}

setup.checkForNewPregnancyHidden = function() {
  if (variables().PlayerPregnant || variables().PregnancyWeek) {
    return // already pregnant
  }

  var recentVaginal = setup.getPossibleConceptions(true)
  var isPregnant
  recentVaginal.forEach(function(fuck) {
    fuck.checkedForPregnancy = "hidden"
    if (!isPregnant) {
      var areDefinitelyOvulating = (fuck.ovulating && !variables().PlayerProtectionPill) || fuck.noPill
      var firstTimeBoost = setup.isFirstVaginal(fuck) ? 0.2 : 0
      fuck.conception = setup.checkForPregnancy(fuck, firstTimeBoost, areDefinitelyOvulating)
      fuck.checkedForPregnancy = "hidden"
      if (fuck.conception) {
        isPregnant = true // but player doesn't know yet, so don't set visible state variable
        if (variables().MenstrualWeek == 4) {
          variables().PregnancyWeek = -1
        } else {  
          variables().PregnancyWeek = variables().MenstrualWeek
        }
        variables().MenstrualWeek = 0
      }
    }
  })
}

setup.checkForNewPregnancy = function(pregnancyTestType, oddsBoost) {
  if (variables().PlayerPregnant) {
    return {isPregnant: false, possibleFathers: []} // already pregnant
  } else if (variables().StoryKeys && variables().StoryModePregnant) {
    var recentVaginal = setup.getPossibleConceptions()
    var storyModePregnancy = variables().StoryModePregnant[pregnancyTestType]
    if (storyModePregnancy) {
      var luckyFuck = recentVaginal.find(function(fuck) {return fuck.name == storyModePregnancy || fuck.anon == storyModePregnancy});
      if (!luckyFuck) {
  		  luckyFuck = recentVaginal[Math.floor(Math.random() * recentVaginal.length)]
      }

      var possibleFathers = Array.from(new Set(recentVaginal.map(function(fuck) {
        return setup.getPartnerName(fuck)
      })))

		  luckyFuck.conception = true

      return {
		  	isPregnant: true,
  			possibleFathers,
	  		conceptionEvent: luckyFuck,
		  	actualFather: setup.getPartnerName(luckyFuck),
  			count: recentVaginal.length
	  	}
    } else {
      recentVaginal.forEach(function(fuck) {
        fuck.conception = false
        fuck.checkedForPregnancy = pregnancyTestType
      })
      return {isPregnant: false, possibleFathers: []} 
    }
  } else {
    var recentVaginal = setup.getPossibleConceptions()
    var possibleFathers = Array.from(new Set(recentVaginal.map(function(fuck) {
      return setup.getPartnerName(fuck)
    })))

    var unrevealedPregnancyEvent = setup.getUnrevealedPregnancy(pregnancyTestType)
    if (unrevealedPregnancyEvent) {
       var actualFather = setup.getPartnerName(unrevealedPregnancyEvent)
       return {isPregnant:true, possibleFathers, actualFather, conceptionEvent:unrevealedPregnancyEvent, count: recentVaginal.length}
    }
    
    var isPregnant, actualFather, conceptionEvent
    recentVaginal.forEach(function(fuck) {
      if (isPregnant) {
        fuck.checkedForPregnancy = "already pregnant"
      } else if (fuck.checkedForPregnancy == "hidden" && !fuck.conception) {
        fuck.checkedForPregnancy = pregnancyTestType
      } else {
				var areDefinitelyOvulating = (fuck.ovulating && !variables().PlayerProtectionPill) || fuck.noPill
        var firstTimeBoost = setup.isFirstVaginal(fuck) ? 0.2 : 0        
        fuck.conception = setup.checkForPregnancy(fuck, Math.max(firstTimeBoost, oddsBoost), areDefinitelyOvulating)
        fuck.checkedForPregnancy = pregnancyTestType
        if (fuck.conception) {
          isPregnant = true // but player doesn't know yet, so don't set visible state variable
          conceptionEvent = fuck
          actualFather = setup.getPartnerName(fuck)
        }
      }
    })

    return {isPregnant, possibleFathers, actualFather, conceptionEvent, count: recentVaginal.length}
  }
}

setup.overrideForcePregnancy = function(pregnancyTestType) {
  var recentVaginal = setup.getPossibleConceptions()
	var normalCheck = setup.checkForNewPregnancy(pregnancyTestType, 0.25)

  if (variables().PlayerPregnant || normalCheck.isPregnant) {
		// pregnant without override, do nothing extra
		return normalCheck 
	} else {
		// they somehow managed to not get pregnant, but the story expects them to, so lets fix that

		if (recentVaginal.length === 0) {
			// how did we end up here? This shouldn't have been called if they aren't sleeping with any guys.  Aborting pregnancy override
			return normalCheck
		}

    var possibleFathers = Array.from(new Set(recentVaginal.map(function(fuck) {
      return setup.getPartnerName(fuck)
    })))

		var luckyFuck = recentVaginal[Math.floor(Math.random() * recentVaginal.length)]
		luckyFuck.conception = true

		return {
			isPregnant: true,
			possibleFathers,
			conceptionEvent: luckyFuck,
			actualFather: setup.getPartnerName(luckyFuck),
			count: recentVaginal.length
		}
	}
}

setup.specialProjectPossibleImpregnated = function () {
  var projectFucks = variables().sex.filter(function(fuck) {return fuck.anon == "Remote Tester"});
  var projectConception = projectFucks.filter(function(fuck) {return fuck.conception});
  var projectAlreadyPregnant = projectFucks.filter(function(fuck) {return fuck.checkedForPregnancy == "already pregnant"});
  return projectConception.length > 0 || projectAlreadyPregnant.length > 0;
}

setup.haveBaby = function (boyNames, girlNames) {
  // TODO Update this to make sure name is unique if they already have kids
  var nameIndex = Math.floor(Math.random() * (boyNames.length + girlNames.length));
  var isGirl = (nameIndex >= boyNames.length);
  var name = (isGirl ? girlNames[nameIndex - boyNames.length] : boyNames[nameIndex]);
  var sex = (isGirl ? 'female' : 'male');
  variables().children.push({ name, sex });
  variables().PlayerMother = 1;
  variables().PlayerPregnant = 0;
  variables().PregnancyCheck = null;
  return isGirl;
}

::NeighbourFunctions [script] <350,50>
setup.addNeighbour = function (name) {
	return variables().neighbours.push(name)
}

setup.isNeighbour = function (name) {
	return variables().neighbours.indexOf(name) >= 0
}

setup.isFormerNeighbour = function (name) {
	return variables().FormerNeighbours && variables().FormerNeighbours.indexOf(name) >= 0
}

setup.removeNeighbour = function (name) {
	variables().neighbours = setup.removeItem(variables().neighbours, name)
  if (variables().FormerNeighbours) {
    variables().FormerNeighbours.push(name);
  } else {
    variables().FormerNeighbours = [name]
  }
}

setup.otherRoommate = function (name) {
  if (variables().neighbours[0] == name) {
    return variables().neighbours[1];
  } else {
    return variables().neighbours[0];
  }
}

::DatingFunctions [script] <400,50>
setup.startDating = function (name) {
	variables().exes = setup.removeItem(variables().exes, name)
	variables().dating = setup.addIfNeeded(variables().dating, name)
	variables().fwb = setup.removeItem(variables().fwb, name)
	variables().friendzone = setup.removeItem(variables().friendzone, name)
}

setup.breakupWith = function (name) {
	variables().exes = setup.addIfNeeded(variables().exes, name)
	variables().dating = setup.removeItem(variables().dating, name)
	variables().fwb = setup.removeItem(variables().fwb, name)
	variables().friendzone = setup.removeItem(variables().friendzone, name)
}

setup.makeFWB = function(name) {
	variables().exes = setup.removeItem(variables().exes, name)
	variables().dating = setup.removeItem(variables().dating, name)
	variables().fwb = setup.addIfNeeded(variables().fwb, name)
	variables().friendzone = setup.removeItem(variables().friendzone, name)
}

setup.friendZone = function(name) {
	variables().exes = setup.removeItem(variables().exes, name)
	variables().dating = setup.removeItem(variables().dating, name)
	variables().fwb = setup.removeItem(variables().fwb, name)
	variables().friendzone = setup.addIfNeeded(variables().friendzone, name)
}

setup.areDating = function (name) {
	return variables().dating.indexOf(name) >= 0
}

setup.areDatingAny = function (names) {
  return names.find(function(name) {return setup.areDating(name)});
}

setup.haveGirlfriend = function () {
  var potentialGirlfriends = ["Kate", "Veronica", "Bailey", "Ellie"];
  return setup.areDatingAny(potentialGirlfriends);
}

setup.isBoyfriendBlack = function () {
  var potentialBlackBoyfriends = ["Jayden"];
  return setup.areDatingAny(potentialBlackBoyfriends);
}

setup.buddyIsDating = function (name) {
 	return variables().BuddyDating == name
}

setup.buddyHasGirlfriend = function () {
  if (setup.areDating("Bailey")) {
    return true;
  }

  var potentialGirlfriends = ["Ava", "Kelsey"];
  return potentialGirlfriends.find(function(name) {return setup.buddyIsDating(name)});
}

setup.buddyHasBoyfriend = function () {
  return variables().BuddyDating && !setup.buddyHasGirlfriend();
}

setup.isEx = function (name) {
	return variables().exes.indexOf(name) >= 0
}

setup.haveDated = function (name) {
	return setup.areDating(name) || setup.isEx(name)
}

setup.isFWB = function(name) {
	return variables().fwb.indexOf(name) >= 0
}

setup.isFriendzoned = function(name) {
	return variables().friendzone.indexOf(name) >= 0
}

::ChastityFunctions [script]
setup.beltMode = function() {
  if (variables().JobBetaTester) {
    return variables().JobBetaTester;
  } else if (variables().ComputerChastityMode) {
    return variables().ComputerChastityMode;
  } else if (variables().PlayerChastityBelt) {
    return "Manual"
  } else {
    return null;
  }
}

setup.beltOwner = function() {
  if (variables().ComputerChastityOwner) {
    return variables().ComputerChastityOwner;
  } else if (variables().Keyholder) {
    return variables().Keyholder;
  } else {
    return null;
  }
}

::EventFunctions [script] <405,50>
$(document).on(':passagestart', function (ev) {
	setup.addDetailsToRecentSex()
})

::AchievementFunctions [script] <417,50>
setup.getAchievementDetails = function() {
  // goldstar: {text: "Gold Star Lesbian", image: "GoldStar.jpg"},
	return {
		married: {text: "Married", image: "Married.png", alwaysShow:true,
      altImage: {poly: "Married-Poly.jpg"}
    },
    bite: {text: "Taking a bite out of crime", image: "Bite.jpg"},
		childfree: {text: "Childfree", image: "NoBaby.png"},
    firsttime: {text: "Beginner's Luck", image: "FirstTime.jpg"},
    foreverVirgin: {text: "Forever a Virgin", image: "LipBite.jpg"},
    friends: {text: "Reuniting with Old Friends", image: "Friends.jpg"},
    girlpower: {text: "Choosing This Life", image: "GirlPower.png"},
    keychain: {text: "Experienced chastity keyholder", image: "Keychain.png"},
    loopholeBaby: {text: "Loophole Pregnancy", image: "LoopholeViolation.jpg"},
		mileHigh: {text: "Mile High Club", image: "MileHigh.gif"},
		mother: {text: "Gave Birth", image: "Baby.jpg"},
    otherMother: {text: "Other Mother", image: "OtherMother.png", alwaysShow:true},
    reader: {parts: ["halo", "shortterm", "education", "eighteen", "crime", "family", "employment", "tourism"], text: "Voracious Reader", image: "Reader.jpg"},
    sisters: {text: "Three Sisters", image: "Sisters.jpg"},
    sistersForever: {text: "Sisters Forever", image: "Sisters2.png"},
		train: {text: "Serving a Train", image: "Train.jpg"},
    twopregnant: {text: "Two for One Deal", image: "TwoPregnant.png"},
		underdog: {text: "Underdog Wins", image: "Underdog.jpg"},
    virgin: {text: "His first time", image: "Cherry.png"},

    dead: {text: "Managed to die in a porn game", image: "Tombstone.png", alwaysShow:true},
    divorced: {text: "Divorced", image: "Divorced.png", alwaysShow:true},
		dropout: {text: "Dropped out of College", image: "DropOut.png", alwaysShow:true},
		expelled: {text: "Expelled", image: "Expelled.jpg", alwaysShow:true},
    graduate: {text: "Graduated College", image: "Graduate.jpg", alwaysShow:true},
    maleAgain: {text: "Changed Back", image:"ChangeBack.jpg", alwaysShow:true},
    murderer: {text: "Murderer!", image:"Murder.jpg", alwaysShow:true},
		pregnant: {text: "Pregnant", image: "Pregnant.jpg", alwaysShow:true},
		pregnantWife: {text: "Pregnant Wife", image: "PregnantWife.jpg", alwaysShow:true},
    purple: {text: "A third option", image:"Purple.jpg", alwaysShow:true},

    fwb: {numRequired: 6, text: "I've got a friend in me.", image: "FWB.jpg"},
		threesome: {parts: ["MFM", "FMF", "FFF"], text: "Three Threesomes: MFM, FMF, and FFF", image: "Threesome.png"},

		andrewLargeFamily: {text: "Large Family", image: "LargeFamily.jpg", isEnding: true},
    andrewNoKids: {text: "Obedient Wife", image: "NoKids.jpg", isEnding: true},
		andrewSmallFamily: {text: "Small Family", image: "SmallFamily.png", isEnding: true},
    armyWife: {text: "Army Wife", image:"ArmyWife.jpg", isEnding:true},
    bossBabe: {text: "Boss Babe", image:"BossBabe.jpg", isEnding:true},
    breeder: {text: "Professional Surrogate", image: "Breeder.jpg", isEnding:true},
    breedingPet: {text: "Breeding Pet", image: "BreederPet.jpg", isEnding:true},
    catgirl: {text: "Catgirl Pet", image:"CatGirl.jpg", isEnding:true},
    chastity: {text: "Chaste Wife", image: "Chastity.jpg", isEnding:true},
    chastityParole: {text: "Chaste Parolee", image:"ChastityDOC.jpg", isEnding:true},
		concubine: {text: "Prince's Concubine", image: "Concubine.jpg", isEnding:true},
    cougar: {text: "Cougar", image:"Cougar.png", isEnding:true},
    cuckqueen: {text: "Cuckqueen", image:"Cuckqueen.png", isEnding:true},
		cumslut: {text: "Cum Slut", image: "Cumslut.png", isEnding: true},
    denial: {text: "Permanent Denial", image: "Denial.png", isEnding: true},
		farmGirl: {text: "Country Girl", image: "FarmGirl.png", isEnding: true},
    freeUse: {text: "Free Use Woman", image:"FreeUse.jpg", isEnding:true},
    hypno: {text: "Stepford Wife", image: "Hypno.gif", isEnding:true},
		kenWife: {text: "Artist's Muse", image: "Art.jpg", isEnding: true},
    lesbianSub: {text: "Submissive Lesbian Wife", image: "LesbianSub.jpg", isEnding:true},
		memoryWipe: {text: "Memory Wipe", image: "CleanMind.jpg", isEnding:true},
		paulWife: {text: "Trophy Wife", image: "TrophyWife.jpg", isEnding:true},
    permaChaste: {text: "Permanent Chastity", image:"PermaChaste.jpg", isEnding:true},
    permaChasteTogether: {text: "Permanent Chastity Together", image:"PermaChasteTogether.png", isEnding:true},
    poly: {text: "Polyamorous Wife", image: "Poly.jpg", isEnding:true},
    prisonBitch: {text: "Prison Bitch", image:"PrisonBitch.jpg", isEnding:true},
    prisonKilled: {text: "Killed in Prison", image:"Tombstone.png", isEnding:true},
    prisonLife: {text: "Life without Parole", image:"Jail.png", isEnding:true},
    purplePrison: {text: "Purple Prison Prostitute", image:"PurplePrison.jpg", isEnding:true},
		resortPet: {text: "Permanent Vacation", image: "Pet.jpg", isEnding:true},
		slave: {text: "Enslaved", image: "Slave.jpg", isEnding: true},
    snitch: {text: "Snitches Get Stitches", image:"Snitches.jpg", isEnding: true},
    stepmom: {text: "Stepmother", image: "StepMother.png", isEnding:true},
    sugarBaby: {text: "Sugar Baby", image:"Lolipop.jpg", isEnding:true},
    swingers: {text: "Swingers", image:"Swingers.jpg", isEnding:true},
    uncle: {text: "Submissive Wife", image: "Uncle.png", isEnding:true},
    whore: {text: "Street Whore", image:"Whore.jpg", isEnding:true}
	}
}

setup.getAchievements = function() {
	var achievements = localStorage.getItem("student-x-change-program.achievements")
	if (achievements) {
		return JSON.parse(achievements)
	} else {
		return []
	}
}

setup.getAchievementSaveData = function() {
	var achievements = localStorage.getItem("student-x-change-program.achievements")
	return btoa(achievements)
}

setup.restoreLoadedAchievementData = function(saveData) {
	try {
		var achievements = JSON.parse(atob(saveData))
		if (achievements.length > 0) {
			setup.saveAchievements(achievements)
			return true
		} else {
			console.error("Empty achievements load attempted")
			return false
		}
	} catch (ex) {
		console.error(ex)
		return false		
	}
}

setup.saveAchievements = function(achievements) {
	localStorage.setItem("student-x-change-program.achievements", JSON.stringify(achievements))
}

setup.getAchievementParts = function(mainAchId) {
  var count = 0;
  var currAchievements = setup.getAchievements()
  currAchievements.forEach((achId) => {
    var currMainId = achId.split(":")[0];
    if (currMainId == mainAchId) {
      count++;
    }
  });

  return count;
}

setup.addMultipartAchievement = function(achId) {
	var currAchievements = setup.getAchievements()
	if (currAchievements.indexOf(achId) < 0) {
		var newAchievements = currAchievements.concat([achId])
		setup.saveAchievements(newAchievements)
	}
		
	var mainAchId = achId.split(":")[0]
	var achInfo = setup.getAchievementDetails()[mainAchId]
  if (achInfo && achInfo.numRequired) {
    let partsAchieved = setup.getAchievementParts(mainAchId);
    if (partsAchieved >= achInfo.numRequired) {
      return setup.addAchievement(mainAchId)
    } else {
      return false;
    }
  } else if (achInfo && achInfo.parts && achInfo.parts.length) {
  	let hasAllParts = true
	  achInfo.parts.forEach((part) => {
		  if (!setup.hasAchievement(`${mainAchId}:${part}`)) {
			  hasAllParts = false
		  }
	  })

  	return hasAllParts && setup.addAchievement(mainAchId)
  } else {
    return false;
  }
}

setup.addAchievement = function(achId) {
	if (achId.indexOf(":") >= 0) {
		return setup.addMultipartAchievement(achId)
	}

	var currAchievements = setup.getAchievements()
	if (currAchievements.indexOf(achId) < 0) {
		var newAchievements = currAchievements.concat([achId])
		setup.saveAchievements(newAchievements)
		return true
	} else {
		return setup.getAchievementDetails()[achId].alwaysShow
	}
}

setup.clearAchievements = function() {
	setup.saveAchievements([])
}

setup.hasAchievement = function(achId) {
	return setup.getAchievements().indexOf(achId) >= 0
}

setup.getAchievementCount = function() {
	return setup.getAchievements().filter((achId) => {return achId.indexOf(":") < 0}).length
}

setup.getPossibleNonEndingActivements = function() {
	var details = setup.getAchievementDetails()
	let achievements = []
	for (let ach in details) {
		if (!details[ach].isEnding) {
			achievements.push(ach)
		}
	}
	return achievements
}

setup.getPossibleEndings = function() {
	var details = setup.getAchievementDetails()
	let endings = []
	for (let ach in details) {
		if (details[ach].isEnding) {
			endings.push(ach)
		}
	}
	return endings
}

setup.getAchievementTable = function() {
	var st = "<table>\n"

	var achToRow = (achId) => {
		var achInfo = setup.getAchievementDetails()[achId]
		if (achId.indexOf(":") >= 0) {
			return ""
		} else if (!achInfo) {
		 	return "<tr><td colspan=2>Unknown Achievement: " + achId + "</td></tr>\n"
		} else if (achInfo.isEnding) {
		 	return ""
		} else {
			var imgText = (achInfo.image) ? "<img src=\"PartAch/" + achInfo.image + "\" hspace=\"10\" vspace=\"10\" height=\"100\" align=\"left\"/>" : ""
		 	return "<tr><td>" + imgText + "</td><td>" + achInfo.text + "</td></tr>\n"	
		}
	}

	st += setup.getAchievements().map(achToRow).join("")

	st += "</table>\n"
	return st
}

setup.getAchievementEndingTable = function() {
	var st = "<table>\n"

	var achToRow = (achId) => {
		var achInfo = setup.getAchievementDetails()[achId]
		if (achInfo && achInfo.isEnding) {
			var imgText = (achInfo.image) ? "<img src=\"PartAch/" + achInfo.image + "\" hspace=\"10\" vspace=\"10\" height=\"100\" align=\"left\"/>" : ""
		 	return "<tr><td>" + imgText + "</td><td>" + achInfo.text + "</td></tr>\n"	
		} else {
		 	return ""
		}
	}

	st += setup.getAchievements().map(achToRow).join("")

	st += "</table>\n"
	return st
}

setup.getAchievementEndingCount = function() {
	return setup.getAchievements().filter((ach) => {
		var achInfo = setup.getAchievementDetails()[ach]
		return achInfo && achInfo.isEnding
	}).length
}

setup.getTotalEndingCount = function() {
	return setup.getPossibleEndings().length
}

setup.getAchievementNonEndingCount = function() {
  	return setup.getAchievements().filter((ach) => {
		var achInfo = setup.getAchievementDetails()[ach]
		return achInfo && !achInfo.isEnding
	}).length
}

setup.getTotalNonEndingCount = function() {
	return setup.getPossibleNonEndingActivements().length
}

::Achievement [script] <450,50>
// adapted from notify.js, by chapel; for sugarcube 2 version 1.0.0
$(document.body).append("<div id='achievement'></div>");
$(document).on(':achievement', function (e) {
    if (e.message && typeof e.message === 'string') {
        var achIds = e.message.trim().split("+");

        var message = "";
        for (let i = 0; i < achIds.length; i++) {
          var achId = achIds[i];
          var altId = null;
          if (achId.indexOf("%")) {
            var parts = achId.split("%");
            achId = parts[0];
            altId = parts[1];
          }

          let achInfo = setup.getAchievementDetails()[achId]
          if (!achInfo) {
            achInfo = { text: "Unknown Achievement: " + achId }
          }

          var imagePath = altId ? achInfo.altImage[altId] : achInfo.image;
          var imageText = achInfo.image ? "<img src=\"PartAch/" + imagePath + "\" height=\"200\"><br>" : ""				
          var endingText = achInfo.isEnding ? "The End: " : ""

          message += imageText + (endingText + achInfo.text).replace(" ","&nbsp;")
        } 

        e.message = message;        
				
        // classes
        if (e.class) {
            if (typeof e.class === 'string') {
                e.class = 'open macro-achievement ' + e.class;
            } else if (Array.isArray(e.class)) {
                e.class = 'open macro-achievement ' + e.class.join(' ');
            } else {
                e.class = 'open macro-achievement';
            }
        } else {
            e.class = 'open macro-achievement';
        }
        
        // delay
        if (e.delay) {
            if (typeof e.delay !== 'number') {
                e.delay = Number(e.delay)
            }
            if (Number.isNaN(e.delay)) {
                e.delay = 5000;
            }
        } else {
            e.delay = 5000;
        }
        
        $('#achievement')
            .empty()
            .wiki(e.message)
            .addClass(e.class)
                
        setTimeout(function () {
            $('#achievement').removeClass();
        }, e.delay);
    }
});

// <<achievement delay 'classes'>> message <</achievement>>
Macro.add('achievement', {
       tags : null,
    handler : function () {
        
        // set up
        var msg     = this.payload[0].contents, 
            time    = false, 
            classes = false, i;
        
        // console.log(`achievement: ${msg}`);
        // arguments
        if (this.args.length > 0) {
            if (typeof this.args[0] === 'number') {
                time    = this.args[0];
                classes = (this.args.length > 1) ? this.args.slice(1).flat() : false;
            } else {
                classes = this.args.flat().join(' ');
            }
        }

        var achIds = msg.trim().split("+");
        var toTrigger = []
        for (let i = 0; i < achIds.length; i++) {
          var achId = achIds[i];
          var isMultiPart = (achId.indexOf(":") >= 0)
          var isAltImage = (achId.indexOf("%") >= 0)

          if (isMultiPart) {
            if (setup.addMultipartAchievement(achId)) {
              toTrigger.push(achId.split(":")[0]);
            }
          } else if (isAltImage) {
            if (setup.addAchievement(achId.split("%")[0])) {
              toTrigger.push(achId.split(":")[0]);
            }
          } else {
            if (setup.addAchievement(achId)) {
              toTrigger.push(achId);
            }
          }

          // fire event
          $(document).trigger({
              type    : ':achievement',
              message : toTrigger.join("+"),
              delay   : time,
              class   : classes
          });
        }
    }
});

::PageMessages [script] <470,50>
setup.pageMessage = function(msg) {
  if (!variables().pageMessages) {
    variables().pageMessages = []
  }

  variables().pageMessages.push(msg)
}

::PassageHeader <475,50>
<<nobr>>
  <span style="display:none"><<if $playerName>>$playerName<<if $MindBlank>>Marie<</if>>: <</if>></span>
  <<set $pageMessages = []>>
<!--  DEBUG: $StoryKeys<br>  DEBUG2: $StoryKeysLearn<br> -->
<</nobr>>

::PassageFooter <480,50>
<<nobr>>
  <span id="StoryKeyFlag" style="display:none">TRUE</span>
  <span id="StoryModeMessage"><<if $StoryKeys>><br><br><i>(Story mode - press "X" to disable)</i><</if>></span>
  <br><br>
  <i>
    <<print $pageMessages.join("<br>")>>
  </i>
<</nobr>>
